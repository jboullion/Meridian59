AstarPath

constants:
	include blakston.khd
resources:

classvars:

vbDebugItems = FALSE

properties:

plPath = $

%Room we are moving within
poRoom = $

piStartRow = 0
piStartCol = 0
piStartRow_fine = 0
piStartCol_fine = 0

piEndRow = 0
piEndCol = 0
piEndRow_fine = 0
piEndCol_fine = 0

% here we track how much the
% destination changes (in fine units)
piDestRowOffset = 0
piDestColOffset = 0

poFrom = $
poTo = $

plDebugItems = $

messages:

Constructor(oFrom = $, oTo = $)
{	
	poFrom = oFrom;
	poTo = oTo;
	plPath = [];
	
	poRoom = Send(oFrom,@GetOwner);
	piStartRow = Send(oFrom,@GetRow);
	piStartCol = Send(oFrom,@GetCol);
	piStartRow_fine = Send(oFrom,@GetFineRow);
	piStartCol_fine = Send(oFrom,@GetFineCol);	
	piEndRow = Send(oTo,@GetRow);
	piEndCol = Send(oTo,@GetCol);
	piEndRow_fine = Send(oTo,@GetFineRow);
	piEndCol_fine = Send(oTo,@GetFineCol);
	
	if vbDebugItems AND plDebugItems <> $
	{
		Send(self,@RemoveDebugItems);
	}
	plPath = CreateAstarPath(Send(poRoom,@GetRoomData),piStartRow,piStartCol,piEndRow,piEndCol,
                             piStartRow_fine,piStartCol_fine,piEndRow_fine,piEndCol_fine);
	if vbDebugItems
	{
		Send(self,@CreateDebugItems);
	}

	return;
}

Recreate()
{
	return;
}

TargetMoved(row = $, col = $, fine_row = FINENESS_HALF, fine_col = FINENESS_HALF)
"sent when we need to recalculate our path due to moving targets"
{
    local dr, dc;

	% get delta of old destination and new in fine units
    dr = ((row * FINENESS) + fine_row) - ((piEndRow * FINENESS) + piEndRow_fine);
	dc = ((col * FINENESS) + fine_col) - ((piEndCol * FINENESS) + piEndCol_fine);

	% add it to tracked offsets so far
	piDestRowOffset = piDestRowOffset + dr;
	piDestColOffset = piDestColOffset + dc;
	
	% only recalibrate astar if the destination offsets
	% exceed a threshold (e.g. target moved too far away from old destination)
	% this is important because a running player otherwise triggers recreation at 70ms intervals.
	% With the current values, the target must have moved at least 2 big square
	% away from the old destination before we recalculate the path.
	% This can be decreased further to reduce CPU load
	if abs(piDestRowOffset) < (2*FINENESS) AND abs(piDestColOffset < (2*FINENESS))
	{
		return;
	}
	
	% actually rebuild path
	% unset offsets first
	piDestRowOffset = 0;
	piDestColOffset = 0;
	
	plPath = [];

	% update start coordinates
	piStartRow = Send(poFrom,@GetRow);
	piStartCol = Send(poFrom,@GetCol);
	piStartRow_fine = Send(poFrom,@GetFineRow);
	piStartCol_fine = Send(poFrom,@GetFineCol);

	% update end coordinates
	piEndRow = row;
	piEndCol = col;
	piEndRow_fine = fine_row;
	piEndCol_fine = fine_col;

	if vbDebugItems AND plDebugItems <> $
	{
		Send(self,@RemoveDebugItems);
	}
	plPath = CreateAstarPath(Send(poRoom,@GetRoomData),piStartRow,piStartCol,piEndRow,piEndCol,
                             piStartRow_fine,piStartCol_fine,piEndRow_fine,piEndCol_fine);
	if vbDebugItems
	{
		Send(self,@CreateDebugItems);
	}
	return;
}

CalculateStep(oTarget = $)
"Returns the next step on the monster's path"
{
	local i; 
	
	%get the last item of the plPath list, or our first move
	if plPath <> $
	{
		i = First(plPath);
		%remove that node from the list
		plPath = DelListElem(plPath,i);
		return i;
	}
	else %path not viable, or some other reason to move with the old system
	{
		return $;
	}
	
	return $;
}

CreateDebugItems()
"creates a line of apples showing the final path"
{
	local oDebugItem, i, r, c, rfine, cfine;

	Debug("plPath:",plPath);
	for i in plPath
	{	
		oDebugItem = Create(&Apple);
		plDebugItems = Cons(oDebugItem,plDebugItems);

		% convert highres-scale to big/fine
        r = (Nth(i,1) * 16) / FINENESS;
		c = (Nth(i,2) * 16) / FINENESS;
        rfine = (Nth(i,1) * 16) MOD FINENESS;
		cfine = (Nth(i,2) * 16) MOD FINENESS;
		
		Send(SYS,@PutInRoom,#what=oDebugItem,#rid=Send(poRoom,@GetRoomNum),
			#row=r,#col=c,#fine_row=rfine,#fine_col=cfine);
	}
	return;
}

RemoveDebugItems()
"removes debug apples"
{
	local i;
	for i in plDebugItems
	{
		Send(i,@Delete);
	}
	plDebugItems = $;
	return;
}

GetTarget()
{
	return poTo;
}

Delete()
{
	return;
}


end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
