AstarPath

constants:
	include blakston.khd
resources:

classvars:

properties:

plOpen = $
plClosed = $

%Room we are moving within
poRoom = $

piStartRow = 0
piStartCol = 0

piEndRow = 0
piEndCol = 0

poFrom = $
poTo = $

poNextMove = $

plDebugItems = $

messages:

Constructor(oFrom = $, oTo = $)
{
	local oRoom, iStartRow, iStartCol, iEndRow, iEndCol;
	
	plOpen = [];
	plClosed = [];
	
	poFrom = oFrom;
	poTo = oTo;
	
	poRoom = Send(oFrom,@GetOwner);
	piStartRow = (Send(oFrom,@GetRow));
	piStartCol = (Send(oFrom,@GetCol));
	piEndRow = (Send(oTo,@GetRow));
	piEndCol = (Send(oTo,@GetCol));
	
	Send(self,@RemoveDebugItems);
	
	Send(self,@Constructed);
	return;
}

Recreate()
{
	local i;
	
	for i in plOpen
	{
		Send(i,@Recreate);
	}
	for i in plClosed
	{
		Send(i,@Recreate);
	}
	return;
}

Constructed()
{
	local oStartNode;
	%%creates the starting position node
	oStartNode = Send(self,@CreateNode,#iRow=piStartRow,#iCol=piStartCol);
	%Debug ("oStartNode",oStartNode);
	if oStartNode <> $
	{
		Send(self,@ScanNode,#oNode=oStartNode);
	}
	%Uncomment To Calculate the Whole Path when created 
	Send(self,@CalculatePath);
	return;
}

%Calculates the entire path
CalculatePath()
{
	local i;
	i = 0;
	%%stop calculating if we arrived at the end, or if we're calculating more than 50 steps (closed list), or
	%%if we've got more than 50 * 8 (400) items on the open list, to prevent infinite loops
	while i < 1 and Length(plClosed) < 50 and Length(plOpen) < 400
	{
		i = Send(self,@FindNextMove);
	}
	return;
}

%Checks if Destination has changed before calculating the next step, if so, starts over.
%Used for Monster movement
CalculateStep(oTo = $)
{
	local i; 
	%check if we changed targets (monsters may have a new enemy, or the ally they are seeking
	%may have been slain, etc.
	if oTo <> poTo
	{
		poTo = oTo;
		Send(self,@Constructor,#oFrom=poFrom,#oTo=poTo);
	}
	%check if the target changed position since our last move
	if Send(oTo,@GetRow) <> piEndRow or Send(oTo,@GetCol) <> piEndCol
	{
		Send(self,@Constructor,#oFrom=poFrom,#oTo=poTo);
	}
	
	%Instead of finding the next move here, lets work off a pre-calculated path
	% = Send(self,@FindNextMove);
	%if we cannot move, or at our destination
	%if i > 0
	%{
		%return $;
	%}
	%sends the next "step" to caller
	%return poNextMove;
	
	%get the last item of the plClosed list, or our first move
	if plClosed <> $
	{
		i = Nth(plClosed,Length(plClosed));
		%remove that node from the list
		plClosed = DelListElem(plClosed,i);
	}
	else %we ran out of closed nodes, so the path is impossible
	{
		i = $;
	}
	
	return i;
}


CreateNode(iRow = 0, iCol = 0, oParent = $)
{	
	local oNode, i;
	if poRoom <> $ 
	{
		oNode = Create(&AstarNode,#iRow=iRow,#iCol=iCol,#iEndRow=piEndRow,#iEndCol=piEndCol,#oParent=oParent);
		%Debug("CreateNode(",iRow, iCol, oParent,"): oNode",oNode);
		if oNode <> $
		{
			return oNode;
		}
		return FALSE;
	}
	return FALSE;
}

FindNextMove()
{
	local oLowestScoreNode, oDebugItem;
	
	%%Get the square on the open list which has the lowest score.
	oLowestScoreNode = Send(self,@FindLowestScore);
	if oLowestScoreNode = $
	{
		Debug("Lowest Node has 0 value, impossible movement");
		return 1;
	}
	
	%%Remove it from the open list
	if plOpen <> $
	{
		plOpen = DelListElem(plOpen,oLowestScoreNode);
	}
	%%Add it to the closed list
	plClosed = Cons(oLowestScoreNode,plClosed);
	
	%%Are we there yet?
	if Send(oLowestScoreNode,@GetRow) = piEndRow AND Send(oLowestScoreNode,@GetCol) = piEndCol
	{
		oDebugItem = Create(&PlateArmor);
		plDebugItems = Cons(oDebugItem,plDebugItems);
		Send(SYS,@PutInRoom,#what=oDebugItem,#rid=Send(poRoom,@GetRoomNum),#row=Send(oLowestScoreNode,@GetRow),#col=Send(oLowestScoreNode,@GetCol)); %%DEBUG
		%Debug("We have arrived at our destination");
		return 1;	
	}
	else
	{
		oDebugItem = Create(&Apple);
		plDebugItems = Cons(oDebugItem,plDebugItems);
		Send(SYS,@PutInRoom,#what=oDebugItem,#rid=Send(poRoom,@GetRoomNum),#row=Send(oLowestScoreNode,@GetRow),#col=Send(oLowestScoreNode,@GetCol)); %%DEBUG
	}
	
	%%Scan the Node
	Send(self,@ScanNode,#oNode=oLowestScoreNode);
	
	%%Save it for Step-Algorithms
	poNextMove = oLowestScoreNode;
	
	return 0;
}

ScanNode(oNode = $)
{
	local iNodeRow, iNodeCol, oNewNode, oFoundNode;
	iNodeRow = Send(oNode,@GetRow);
	iNodeCol = Send(oNode,@GetCol);
	
	oFoundNode = $;
	%If Walkable
	if Send(poRoom,@CanMoveInRoomProxy,#iStartRow=iNodeRow,#iStartCol=iNodeCol,
		#iEndRow=iNodeRow+1,#iEndCol=iNodeCol)
	{
		oFoundNode = Send(self,@FindClosedNode,#iRow=iNodeRow+1,#iCol=iNodeCol);
		if oFoundNode <> $
		{
			%Debug("Node in Closed List, Skipping");
		}
		else %And not closed
		{	
			%is it in the Open List?
			oFoundNode = Send(self,@FindOpenNode,#iRow=iNodeRow+1,#iCol=iNodeCol);
			if oFoundNode <> $
			{
				%Yes? Recalculate Heueristic
				Send(oFoundNode,@TryNewParent,#oNode=oNode);
			}
			else
			{
				%No? Create a new Node
				oNewNode = Send(self,@CreateNode,#iRow=iNodeRow+1,#iCol=iNodeCol,#oParent=oNode);
				%Debug("Can Move South 1 Row, Adding to Open list",oNewNode);
				plOpen = Cons(oNewNode,plOpen);
			}
		}
	}
	
	oFoundNode = $;
	if Send(poRoom,@CanMoveInRoomProxy,#iStartRow=iNodeRow,#iStartCol=iNodeCol,
		#iEndRow=iNodeRow-1,#iEndCol=iNodeCol)
	{
		oFoundNode = Send(self,@FindClosedNode,#iRow=iNodeRow-1,#iCol=iNodeCol);
		if oFoundNode <> $
		{
			%Debug("Node in Closed List, Skipping");
		}
		else
		{
			%is it in the Open List?
			oFoundNode = Send(self,@FindOpenNode,#iRow=iNodeRow-1,#iCol=iNodeCol);
			if oFoundNode <> $
			{
				%Yes? Recalculate Heueristic
				Send(oFoundNode,@TryNewParent,#oNode=oNode);
			}
			else
			{
				%No? Create a new Node
				oNewNode = Send(self,@CreateNode,#iRow=iNodeRow-1,#iCol=iNodeCol,#oParent=oNode);
				%Debug("Can Move North 1 Row, Adding to Open list",oNewNode);
				plOpen = Cons(oNewNode,plOpen);
			}
		}
	}
	
	oFoundNode = $;
	if Send(poRoom,@CanMoveInRoomProxy,#iStartRow=iNodeRow,#iStartCol=iNodeCol,
		#iEndRow=iNodeRow,#iEndCol=iNodeCol+1)
	{
		oFoundNode = Send(self,@FindClosedNode,#iRow=iNodeRow,#iCol=iNodeCol+1);
		if oFoundNode <> $
		{
			%Debug("Node in Closed List, Skipping");
		}
		else
		{	
			%is it in the Open List?
			oFoundNode = Send(self,@FindOpenNode,#iRow=iNodeRow,#iCol=iNodeCol+1);
			if oFoundNode <> $
			{
				%Yes? Recalculate Heueristic
				Send(oFoundNode,@TryNewParent,#oNode=oNode);
			}
			else
			{
				%No? Create a new Node
				oNewNode = Send(self,@CreateNode,#iRow=iNodeRow,#iCol=iNodeCol+1,#oParent=oNode);
				%Debug("Can Move East 1 Row, Adding to Open list",oNewNode);
				plOpen = Cons(oNewNode,plOpen);
			}
		}
	}
	
	oFoundNode = $;
	if Send(poRoom,@CanMoveInRoomProxy,#iStartRow=iNodeRow,#iStartCol=iNodeCol,
		#iEndRow=iNodeRow,#iEndCol=iNodeCol-1)
	{
		oFoundNode = Send(self,@FindClosedNode,#iRow=iNodeRow,#iCol=iNodeCol-1);
		if oFoundNode <> $
		{
			%Debug("Node in Closed List, Skipping");
		}
		else
		{
			%is it in the Open List?
			oFoundNode = Send(self,@FindOpenNode,#iRow=iNodeRow,#iCol=iNodeCol-1);
			if oFoundNode <> $
			{
				%Yes? Recalculate Heueristic
				Send(oFoundNode,@TryNewParent,#oNode=oNode);
			}
			else
			{
				%No? Create a new Node
				oNewNode = Send(self,@CreateNode,#iRow=iNodeRow,#iCol=iNodeCol-1,#oParent=oNode);
				%Debug("Can Move West 1 Row, Adding to Open list",oNewNode);
				plOpen = Cons(oNewNode,plOpen);
			}
		}
	}
	%North-East
	if Send(poRoom,@CanMoveInRoomProxy,#iStartRow=iNodeRow,#iStartCol=iNodeCol,
		#iEndRow=iNodeRow-1,#iEndCol=iNodeCol+1)
	{
		oFoundNode = Send(self,@FindClosedNode,#iRow=iNodeRow-1,#iCol=iNodeCol+1);
		if oFoundNode <> $
		{
			%Debug("Node in Closed List, Skipping");
		}
		else %And not closed
		{	
			%is it in the Open List?
			oFoundNode = Send(self,@FindOpenNode,#iRow=iNodeRow-1,#iCol=iNodeCol+1);
			if oFoundNode <> $
			{
				%Yes? Recalculate Heueristic
				Send(oFoundNode,@TryNewParent,#oNode=oNode,#diagonal=TRUE);
			}
			else
			{
				%No? Create a new Node
				oNewNode = Send(self,@CreateNode,#iRow=iNodeRow-1,#iCol=iNodeCol+1,#oParent=oNode,#diagonal=TRUE);
				plOpen = Cons(oNewNode,plOpen);
			}
		}
	}
	%South-East
	if Send(poRoom,@CanMoveInRoomProxy,#iStartRow=iNodeRow,#iStartCol=iNodeCol,
		#iEndRow=iNodeRow+1,#iEndCol=iNodeCol+1)
	{
		oFoundNode = Send(self,@FindClosedNode,#iRow=iNodeRow+1,#iCol=iNodeCol+1);
		if oFoundNode <> $
		{
			%Debug("Node in Closed List, Skipping");
		}
		else %And not closed
		{	
			%is it in the Open List?
			oFoundNode = Send(self,@FindOpenNode,#iRow=iNodeRow+1,#iCol=iNodeCol+1);
			if oFoundNode <> $
			{
				%Yes? Recalculate Heueristic
				Send(oFoundNode,@TryNewParent,#oNode=oNode,#diagonal=TRUE);
			}
			else
			{
				%No? Create a new Node
				oNewNode = Send(self,@CreateNode,#iRow=iNodeRow+1,#iCol=iNodeCol+1,#oParent=oNode,#diagonal=TRUE);
				plOpen = Cons(oNewNode,plOpen);
			}
		}
	}
	%North-West
	if Send(poRoom,@CanMoveInRoomProxy,#iStartRow=iNodeRow,#iStartCol=iNodeCol,
		#iEndRow=iNodeRow-1,#iEndCol=iNodeCol-1)
	{
		oFoundNode = Send(self,@FindClosedNode,#iRow=iNodeRow-1,#iCol=iNodeCol-1);
		if oFoundNode <> $
		{
			%Debug("Node in Closed List, Skipping");
		}
		else %And not closed
		{	
			%is it in the Open List?
			oFoundNode = Send(self,@FindOpenNode,#iRow=iNodeRow-1,#iCol=iNodeCol-1);
			if oFoundNode <> $
			{
				%Yes? Recalculate Heueristic
				Send(oFoundNode,@TryNewParent,#oNode=oNode,#diagonal=TRUE);
			}
			else
			{
				%No? Create a new Node
				oNewNode = Send(self,@CreateNode,#iRow=iNodeRow-1,#iCol=iNodeCol-1,#oParent=oNode,#diagonal=TRUE);
				plOpen = Cons(oNewNode,plOpen);
			}
		}
	}
	%South-West
	if Send(poRoom,@CanMoveInRoomProxy,#iStartRow=iNodeRow,#iStartCol=iNodeCol,
		#iEndRow=iNodeRow+1,#iEndCol=iNodeCol-1)
	{
		oFoundNode = Send(self,@FindClosedNode,#iRow=iNodeRow+1,#iCol=iNodeCol-1);
		if oFoundNode <> $
		{
			%Debug("Node in Closed List, Skipping");
		}
		else %And not closed
		{	
			%is it in the Open List?
			oFoundNode = Send(self,@FindOpenNode,#iRow=iNodeRow+1,#iCol=iNodeCol-1);
			if oFoundNode <> $
			{
				%Yes? Recalculate Heueristic
				Send(oFoundNode,@TryNewParent,#oNode=oNode,#diagonal=TRUE);
			}
			else
			{
				%No? Create a new Node
				oNewNode = Send(self,@CreateNode,#iRow=iNodeRow+1,#iCol=iNodeCol-1,#oParent=oNode,#diagonal=TRUE);
				plOpen = Cons(oNewNode,plOpen);
			}
		}
	}
	return;
}

FindLowestScore()
{
	local i, lNodes, lFinal, iLow, iIndex, oFinalNode;
	
	%get a copy of the open list to work with
	lNodes = Send(SYS, @ListCopy,#source=plOpen);
	
	lFinal = $;
	%%Insertion sort
	while lNodes <> $
	{
		iLow = MAX_INT;
		iIndex = $;
		
		for i in lNodes
		{
			if Send(i,@GetScore) < iLow
			{
				iIndex = i;
				iLow = Send(i,@GetScore);
			}
		}
		
		if iIndex = $ OR iLow = MAX_INT
        {
			debug("SORT WENT WAY BAD!");
			
			return $;
		}
		
		lFinal = Cons(iIndex,lFinal);
		lNodes = DelListElem(lNodes,iIndex);
	}
	%%The last item in the list is the lowest score.
	oFinalNode = Nth(lFinal,Length(lFinal));
		
	return oFinalNode;
}

RemoveDebugItems()
{
	local i;
	for i in plDebugItems
	{
		Send(i,@Delete);
	}
	return;
}

Delete()
{
	plOpen = $;
	plClosed = $;
	return;
}

FindClosedNode(iRow = 0, iCol = 0)
{
	local i;
	for i in plClosed
	{
		if Send(i,@GetCol) = iCol AND Send(i,@GetRow) = iRow
		{
			%Debug("Node exists in plClosed:",i,iRow,iCol);
			return i;
		}
	}
	return $;
}

FindOpenNode(iRow = 0, iCol = 0)
{
	local i;
	for i in plOpen
	{
		if Send(i,@GetCol) = iCol AND Send(i,@GetRow) = iRow
		{
			%Debug("Node exists in plOpen:",i,iRow,iCol);
			return i;
		}
	}
	return $;
}

end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
